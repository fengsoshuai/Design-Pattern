[toc]

# 诞生与定义

## 1、诞生

设计模式起源于建筑领域，是对前人经验的总结，为后人设计与开发基于面向对象的软件提供指导方针和成熟的解决方案。 

> 借用 Alexander 的一句话：模式是在特定环境中解决问题的一种方案。
> 最早将模式的思想引入软件工程方法学的是 Gang of Four 的四人组，他们在 1994 年归纳发表了23种在软件开发中使用频率较高的设计模式，旨在用模式来统一沟通面向对象方法在分析、设计和实现间的鸿沟。

由此可以看出，模式本身与具体的应用领域无关，在模式的发现过程中，需要遵循 Rule of Three，也就是说只有经过三种及其以上的不同类型（或不同领域）的系统的检验，一个解决方案才有资格成为模式（从候选模式升级为模式）。

## 2、定义

设计模式（Design Pattern）是一套被反复使用。多数人知晓的，经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。

# 模式的分类

## 1、按照目的分类

根据模式的基本要素中的（模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式）目的，进行分类。换句话说，就是按照模式是为了干什么而设计的来分类。可以分为3类，创建型、结构型和行为型。

### 1.1 创建型

主要用于创建对象。

### 1.2 结构型

主要用于处理类和对象的组合。

### 1.3 行为型

主要用于描述对类或对象怎样交互和怎样分配职责。

## 2、根据范围分类

即模式主要是用于处理类之间的关系还是处理对象之间的关系，分为类模式和对象模式。

### 2.1 类模式

处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。

### 2.2 对象模式

对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。

# `GOF`设计模式的简介

| 模式类别   | 模式名称     | 模式说明                                                     |
| ---------- | ------------ | ------------------------------------------------------------ |
| 创建型模式 | 抽象工厂模式 | 提供了一个创建一系列相关或互相依赖对象的接口，而无须指定他们具体的类。 |
|            | 建造者模式   | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 |
|            | 工厂方法模式 | 将类的实例化操作延迟到子类中完成，即由子类来决定究竟应该实例化哪一个类。 |
|            | 原型模式     | 通过给出一个原型对象来指明所要创建的对象的类型，然后通过复制这个原型对象的方法创建出更多同类型的对象，有些人也叫它为克隆模式。 |
|            | 单例模式     | 确保在系统中某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 |
| 结构型模式 | 适配器模式   | 将一个接口转换成客户希望的另一个接口，从而使接口不兼容的那些类可以一起工作。 |
|            | 桥接模式     | 将抽象部分与它的实现部分分离，使他们都能独立地变化。         |
|            | 组合模式     | 通过组合多个对象形成树形结构以表示“整体-部分”的结构层次，对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。 |
|            | 装饰模式     | 动态的给一个对象增加一些额外的职责。                         |
|            | 外观模式     | 为复杂子系统提供一个一致的接口。                             |
|            | 享元模式     | 通过运用共享技术有效地支持大量细粒度对象的复用。             |
|            | 代理模式     | 给某一个对象提供一个代理，并由代理对象控制对原对象的引用。   |
| 行为型模式 | 职责链模式   | 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 |
|            | 命令模式     | 将一个请求封装为一个对象，从而使得请求调用者和请求接收者解耦。 |
|            | 解释器模式   | 描述如何为语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。 |
|            | 迭代器模式   | 提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示。 |
|            | 中介者模式   | 通过一个中介对象来封装一系列的对象交互，使得个对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。 |
|            | 备忘录模式   | 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 |
|            | 观察者模式   | 定义了对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并自动更新。 |
|            | 状态模式     | 允许一个对象在其内部状态改变时改变它的行为。                 |
|            | 策略模式     | 定义一系列算法，并将每一个算法封装在一个类中，并让它们可以互相替换，策略模式让算法独立于使用它的客户而变化。 |
|            | 模板方法模式 | 定义一个操作中算法的骨架，而将一些步骤延迟到子类中。         |
|            | 访问者模式   | 表示一个作用于某对象结构中的各元素的操作，它使得用户可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 |

> 特别关心：在平常的使用中，往往是不止一个模式单独使用的，一般都是好几个复合使用的，它们会协同工作，完成复杂的设计工作。

# 参考&致谢

文中案例和概念的部分，大多来自《设计模式》清华大学出版社出版，属于重点大学软件工程规划系列教材。